# Введение в `twol`: (мор)фонология

{{< epigraph "*Если в слове «хлеб» сделать четыре ошибки, получится «пиво»*" source="анекдот" >}}

## Фонологическое введение

Преобладающая фонологическая теория в XX веке --- генеративная фонология [@chomsky1968]. Согласно этой теории существует два представления: глубинное (underlying/phonological representation) и поверхностное (surface form, phonetic representation). Фонология в этой теории сводится к набору линейно упорядоченных правил, которые применяются циклически, преобразуя результат работы синтаксической деревации в фонетические цепочки.

(@) глубинное представление > фонологическое правило 1 > фонологическое правило 2 > ... > поверхностное представление.

Из-за того, что правила в этой теории строго упорядочены возникают случаи, когда правила взаимодействуют друг с другом. Классификация таких случаев приводится в работе [@kiparsky1982]:

- питающий порядок (feeding). Так называют порядок, при котором применение одного правила увеличивает количество контекстов применение другого правила, так что другое правило срабатывает. [^feeding]
- блокирующий порядок (bleeding). Так называют порядок, при котором применение одного правила уменьшает количество контекстов применения другого правила, так что другое правило не срабатывает. [^bleedong]
- противопитающий порядок (counterfeeding). Так называют порядок, при котором применение одного правила увеличивает
количество контекстов применение другого правила, однако другое правило не срабатывает.
- противоблокирующий порядок (counterbleeding). Так называют порядок, при котором применение одного правила уменьшает
количество контекстов применения другого правила, однако другое правило все равно срабатывает.

[^feeding]: Вот пример питающего порядка из бразильского португальского (индоевропейские).

    | правило       | форма      | транскрипция      | глосса       |
    |---------------|------------|-------------------|--------------|
    | палатализация | bato       | [bá**t**u]        | бить-1sg     |
    | палатализация | bate       | [bá**tʃ**i]       | бить-3sg     |
    | палатализация | ardo       | [áɾ**d**u]        | жечь-1sg     |
    | палатализация | arde       | [áɾ**dʒ**i]       | жечь-3sg     |
    | эпентеза i    | pacto      | [pák**i**tu]      | соглашение   |
    | эпентеза i    | captar     | [kap**i**táɾ]     | взять в плен |
    | эпентеза i    | psicologia | [p**i**sikoloʒíɐ] | психология   |
    
    А вот взаимодействие правил:
    
    |               | /kaptáɾ/ <br> взять в плен | /áɾdi/ <br> жечь-3sg | /advɛ́χsu/ <br> враждебный | /futbɔ́w/ <br> футбол |
    |---------------|:--------------------------:|:--------------------:|:-------------------------:|:--------------------:|
    | эпентеза I    |           kapitáɾ          |          ---         |          adivɛ́χsu         |        futibɔ́w       |
    | палатализация |             ---            |         áɾdʒi        |         adʒivɛ́χsu         |       futʃibɔ́w       |

[^bleedong]: Вот пример питающего порядка из литовского (индоевропейские).

    | правило    | транскрипция         | перевод   |
    |------------|----------------------|-----------|
    | эпентеза i | [at-koːpʲtʲi]        | прийти    |
    | эпентеза i | [atʲ**i**-tʲeisʲtʲi] | присудить |
    | эпентеза i | [ap-kalʲbʲetʲi]      | оговорить |
    | эпентеза i | [apʲ**i**-putʲi]     | подгнить  |
    | озвончение | [at-praʃʲiːtʲi]      | спросить  |
    | озвончение | [a**d**-gautʲi]      | вернуть   |
    | озвончение | [ap-ʃaukjtji]        | объявить  |
    | озвончение | [a**b**-gautji]      | обмануть  |
    
    А вот взаимодействие правил:
    
    |            | /ap-putʲi/ <br> подгнить | /at-gautʲi/ <br> вернуть | /at-duotʲi/ <br> отдать | /ap-bʲekʲtʲi/ <br> обежать |
    |------------|:------------------------:|:------------------------:|:-----------------------:|:--------------------------:|
    | эпентеза i |        apʲi-putʲi        |            ---           |       atʲi-duotʲi       |        apʲi-bʲekʲtʲi       |
    | озвончение |            ---           |         ad-gautʲi        |           ---           |             ---            |


Вот комиксы, которые по нашей задумке должны дополнительно иллюстрировать разницу между разными порядками.

```{r}
#| layout-ncol: 2

knitr::include_graphics("images/03_01_Russita-feeding.png")
knitr::include_graphics("images/03_02_Russita-bleeding.png")
knitr::include_graphics("images/03_03_Russita-counterfeeding.png")
knitr::include_graphics("images/03_04_Russita-counterbleeding.png")
```

## Двухуровневая фонология/морфология

Двухуровневая фонология/морфология (two level morphology) была разработана в диссертации [@koskenniemi1983]. Стоит отметить, что мы используем данный формализм для моделирования (мор)фонологических правил, однако данный формализм называют двухуровневой морфологией (в том числе и сам автор). Вообще, еще в 1972 вышла диссертация [@johnson1972], в которой автор указывал на некоторые недостатки последовательности фонологических правил, которые были приняты в генеративной фонологии, а также доказывал, что любую последовательность правил можно моделировать при помощи трансдьюсера, однако эта работа осталась незамеченной.

В рамках двухуровневой фонологии/морфологии:

- правила --- посимвольные ограничения на поверхностное представление, которые применяются параллельно.
- правила могут оперировать единицами глубинного (другое название --- лексическое) представления, поверхностного представления или одновременно обоих.

Например, получить из глубинной формы `spy>s` поверхностную форму `spies`  можно двумя правилами (нотацию мы подробнее обсудим позже):

- `y:i <=> _ 0:e`
- `0:e <=> y: _ %>:0`

Первое правило обращается одновременно к глубинному (`0:`) и поверхностному (`:e`) представлениям. Второе правило обращается только к глубинному представлению (`y:`) и поверхностному (`%>:0`) представлениям. 

Использование ограничений, вместо правил, чуть позже возникла в фонологии в виде Теории оптимальности (OT, [@prince1994]), однако в рамках OT предпалагаются, что ограничения носят универсальный характер и есть во всех языках, в то время, как ограничения двухуровневой фонологии/морфологии --- имеют частный внутриязыковой характер.

## Программа `twol`

В данном разделе мы будем обсуждать синтаксис `twol`. Данный раздел основан на [@beesley2003]. Кроме того Элен Картина обратила мое внимание на [пакет `twol`](https://pytwolc.readthedocs.io/en/latest/index.html) для Python, разработанный Киммо Коскенниэми, автором `twol`.

### Техническое введение

Мы будем использовать программу `hfst-twolc`. Чтобы избежать сложностей на начальных этапах курса, мы решили вначале познакомиться с синтаксисом `twol` и попробовать описывать разные языковые явления, не затрудняя всех установкой и запуском нужных программ у себя на компьютере.

- Для начала работы следует, как и раньше, скачать `Makefile`:

```{{shell}}
$ curl -s https://raw.githubusercontent.com/agricolamz/2025_morphological_transducers/refs/heads/main/task_tests/Makefile -o Makefile; make
```

- дальше, как и раньше, следует создать в колабе или у себя на компьютере (если у вас Linux), файл с названием `task.lexd`. В Google Colab для этого достаточно вставить первой строкой кодового блока `%%writefile task.lexd`. Вот пример такого файла:

```{{lexd}}
PATTERNS
Noun (Suffix[-adj] | (Suffix[adj] Inflection))?

LEXICON Noun
ночь
печь

LEXICON Suffix
<dim>:ка
<adj>:н[adj]

LEXICON Inflection
<m><sg><nom>:ой
```

- нововведением является возможность создания файла с названием `task.twol`, в котором будет содержаться код для обработки (мор)фонологии. Не забудьте вставить `%%writefile task.twol` в Google Colab. Вот пример такого файла:

```{{twol}}
Alphabet
  а е й к н о п ч ь ь:0;

Rules

"чк чн пишется без ь"
! например, ночьной -> ночной или печька -> печка

ь:0 <=> _ к;
        _ н;
```

- После того, как вы установили нужные программы и создали файлы, как и раньше, можно посмотреть формы и разборы, которые генерируются трансдьюсером (не забудьте поставить восклицательный знак перед `make` в Google Colab):

```{{shell}}
$ make forms

ночь<dim>:ночка
ночь<adj><m><sg><nom>:ночной
ночь
печь<dim>:печка
печь<adj><m><sg><nom>:печной
печь
```

- Кроме того можно посмотреть анализ/генерацию конкретных форм (не забудьте поставить восклицательный знак перед `make` в Google Colab):

```{{shell}}
$ make analysis FORM="печка"

hfst-lookup: Warning: It is not possible to perform fast lookups with OpenFST, std arc, tropical semiring format automata.
Using HFST basic transducer format and performing slow lookups
> печка	печь<dim>	0,000000
```

```{{shell}}
$ make generation FORM="ночь<adj><m><sg><nom>"

hfst-lookup: Warning: It is not possible to perform fast lookups with OpenFST, std arc, tropical semiring format automata.
Using HFST basic transducer format and performing slow lookups
> ночь<adj><m><sg><nom>	ночной	0,000000
```

- Как и раньше, получившийся трансдьюсер можно протестировать:

```{{shell}}
$ make test_03_01
```

- К сожалению, сейчас, если была получена ошибка из программы `twol` следует удалить лишние созданные файлы перед тем как приступить к исправлению:

```{{shell}}
$ make clean
```


### Структура `.twol` файла {#sec-twol-structure}

Каждый `.twol` файл состоит из нескольких блоков, которые удобно обсуждать на приведенном выше примере:

```{{twol}}
Alphabet                                            # <1>
  а е й к н о п ч ь ь:0;                            # <2>

Rules                                               # <3>

"чк чн пишется без ь"                               # <4>
! например, ночьной -> ночной или печька -> печка   # <5>

ь:0 <=> _ к;                                        # <6>
        _ н;                                        # <7>
```

1. Раздел, которые перечисляет все используемые символы.
2. Декларацией конца раздела является точка с запятой, поэтому иногда удобно писать элементы в несколько строчек, особенно если есть некотрые логические блоки. Из примера видно сокращение: одним символом можно записывать идентичные пары входного и выходного символов (т. е. `й:й` можно записывать как `й`).
3. Раздел с правилами.
4. Название правила (паразительно, но это обязательный элемент [^rule_without_name]).
5. В любом месте файла можно написать комментарий. Начало комментария обозначается восклицательным знаком.
6. Само правило. Оно обычно имеет следующие элементы: какая-то пара входного/выходного символа (`ь:0`), дальше оператор (`<=>`), дальше контекст (`_ к`), все это заканчивается точкой с запятой.
7. Несколько контекстов для одного правила можно записывать вместе. На всякий случай --- отбивка не важна, просто сделал для удобочитаемости.

[^rule_without_name]: Если удалить из работающего файла одно из названий правила получится ошибка, в которой самым явным будет часть сообщения `Error: twol.hfst is not a valid transducer file`.

### Раздел алфавита

Хорошо бы, чтобы раздел алфавита содержал все пары символов (по-английски, symbol pairs или feasible pairs) глубинного и поверхностного представлений, которые представлены в вашем материале. Важно отметить, что `twol` достраивает пары символов из правил, так что программа будет работать и с неполным алфавитом `.twol`. Для нашего примера достаточно следующего файла:

```{{twol}}
Alphabet
  ь;

Rules

"чк чн пишется без ь"

ь:0 <=> _ к;
        _ н;
```

Так как под капотом происходит композиция трансдьюсеров (см. @sec-transducers), то символы, которые не участвуют в правилах `twol`, не будут затронуты. И, единственное, что `twol` не может восстановить, что у нас есть две сущности: `ь:0` и `ь:ь`.

Однако все это из разряда вредных советов. Если вы моделируете язык или даже его фрагмент, лучше перечислить все символы (и их прописные варианты). Это позволит избежать проблем при анализе некачественных входных данных.

### Обращение к разным представлениям {#sec-dif-representations}

Единцы, которыми манипулирует `twol` --- пары глубинного и поверхносного представления. Поэтому в правилах могут появлятся

- полностью определенные единицы, например, `а:ы` или `ь:0`
- единицы, определенные только на одном из представлений
    - глубинном, например, `ы: `
    - поверхностном, например, ` :я`
- placeholder со значением любой знак: ` : ` (еще можно `?`)

### Архифонемы {#sec-archiphonemes}

Иногда (мор)фонологические проблемы можно решать, не постулируя некоторую конкретную сегментную глубинную форму, а используя, так называемые архифонемы[^archiphoneme]. Эти единицы записываются в `lexd` в фигурных скобках, например `{А}`. Существует конвенция, что если архифонема позже только удаляется, то ее пишут строчными буквами, например, `{s}`, а если архифонема представляет собой набор поверхностных форм, то ее пишут заглавными буквами, например, `{А}`. Важно отметить, что в файле `.twol` фигурные скобки нужно экранировать при помощи знака процента `%`. Для примера давайте перемоделируем пример из прошлого раздела:

[^archiphoneme]: Этот термин предложил Н. С. Трубецкой для единиц, находящихся в слабой фонологической позиции и характеризующихся неполным набором признаковых спецификаций (например, оглушение на конце слова в русском). Однако в практике пользователей `lexd` и `twol` архифонемы --- это просто единицы удобные для моделирования. Иногда их используют и для случаев подразумевавшихся Трубецким, например, для моделирования гармонии, но иногда их используют для моделирования других морфонологических сложностей.

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
NounStem Inflection

LEXICON NounStem
мама:мам
папа:пап
няня:нян{j}
Таня:Тан{j}

LEXICON Inflection
<nom><sg>:{А}
<gen><sg>:{Ы}
<pos>:ин
```


###### `twol`

```{{twol}}
Alphabet
  а и м н п я Т
  %{А%}:а %{А%}:я %{Ы%}:ы %{Ы%}:и %{j%}:0;

Rules

"удаляем маркер мягкой основы" 

%{j%}:0 <=> _ ;

"гласные после мягкой основы в именительном" 

%{А%}:я <=> %{j%}:0 _ ;

"гласные после мягкой основы в родительном" 

%{Ы%}:и <=> %{j%}:0 _ ;
```

###### до применения `twol`

```
мама<nom><sg>:мам{А}
мама<gen><sg>:мам{Ы}
мама<pos>:мамин
папа<nom><sg>:пап{А}
папа<gen><sg>:пап{Ы}
папа<pos>:папин
няня<nom><sg>:нян{j}{А}
няня<gen><sg>:нян{j}{Ы}
няня<pos>:нян{j}ин
Таня<nom><sg>:Тан{j}{А}
Таня<gen><sg>:Тан{j}{Ы}
Таня<pos>:Тан{j}ин  
```

###### после применения `twol`

```
мама<nom><sg>:мама
мама<gen><sg>:мамы
мама<pos>:мамин
папа<nom><sg>:папа
папа<gen><sg>:папы
папа<pos>:папин 
няня<nom><sg>:няня
няня<gen><sg>:няни
няня<pos>:нянин
Таня<nom><sg>:Таня
Таня<gen><sg>:Тани
Таня<pos>:Танин
```

###### старый файл `lexd`

```{{lexd}}
PATTERNS
NounStem[hard] Inflection[hard]
NounStem[soft] Inflection[soft]
NounStem Inflection[-hard,-soft]

LEXICON NounStem
мама:мам[hard]
папа:пап[hard]
няня:нян[soft]
Таня:Тан[soft]

LEXICON Inflection
<nom><sg>:а[hard]
<nom><sg>:я[soft]
<gen><sg>:ы[hard]
<gen><sg>:и[soft]
<pos>:ин
```

:::

Следует обратить внимание, на то, что мы не писали правил для пар `{А}:а` и `{Ы}:ы`. `twol` сам использовал указанные нами переходы во всех контекстах, не специализированных правилом перехода после мягких основ. Это поведение напрямую зависит от оператора, используемого в правиле (см. раздел @sec-rule-operators).

Архифонемы позволяют моделировать морфонологические правила, так как мы всегда можем вставить единицу `{some_name}:0`, которая показывает на важную морфонологическую границу, рядом с которой что-то происходит (см. еще @sec-morphonology).

::: {.callout-note}

###### Задание 03_02

В работе [@itkin07: 118] описано чередование *н*~*н'* в русском языке. Попробуйте заполнить раздел `Rules` в файле `.twol`, чтобы получился трансдьюсер, моделирующий следующие формы:

| \<nom\>\<sg\> | \<dat\>\<sg\>  | \<ins\>\<pl\>   | \<gen\>\<pl\>  |
|---------------|----------------|-----------------|----------------|
| _башня_       | _башней_       | _башнями_       | _башен_        |
| _песня_       | _песней_       | _песнями_       | _песен_        |
| _бойня_       | _бойней_       | _бойнями_       | _боен_         |
| _деревня_     | _деревней_     | _деревнями_     | _деревень_     |
| _кухня_       | _кухней_       | _кухнями_       | _кухонь_       |
| _Таня_        | _Таней_        | _Танями_        | _Тань_         |

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
(NounRoot NounInfl)[^[hard,soft]]

LEXICON NounRoot
башня<n>:баш{Е}н[hard]
песня<n>:пес{Е}н[hard]
бойня<n>:бой{Е}н[hard]
деревня<n>:дерев{Е}н[soft]
кухня<n>:кух{О}н[soft]
Таня<n>:Тан[soft]

LEXICON NounInfl
<nom><sg>:я
<dat><sg>:ей
<dat><pl>:ями
<gen><pl>:{GEN.PL}[hard]
<gen><pl>:{GEN.PL}ь[soft]
```

###### `twol`

```{{twol}}
Alphabet
    б ш н п с й д р в к х Т м ь
    а я е у и о
    %{Е%}:0 %{О%}:0 %{GEN.PL%}:0 
    %{Е%}:е %{О%}:о
    й:0
;

Rules

```

:::

:::

### Разделы `Sets` и `Definitions`

Раздел `Sets` --- опциональный раздел `.twol` файла, в котором можно создать группы символов, к которым потом можно обращаться в правилах по имени. Рассмотрим пример моделирования устранение зияния гласных в адыгейском языке [@arkadiev2009: 27--28]:

|         | \<abs\> | 'это не X' <br> \<neg\> | 'это X?' <br> <q> |
|---------|:-------:|:-----------------------:|:-----------------:|
| женщина |  _шъуз_ |        _шъузэп_         |     _шъуза_       |
| мужчина |  _лIы_  |        _лIэп_           |      _лIа_        |
| дом     |  _унэ_  |        _унэп_           |      _уна_        |

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
Root Infl

LEXICON Root
шъуз
лIы
унэ

LEXICON Infl
<abs>:
<neg>:эп
<q>:а
```

###### `twol`

```{{twol}}
Alphabet
    I а з л н п у ш ъ ы э
    а:0 ы:0 э:0;
    
Sets
    Vowels = а ы э;

Rules

"устранение зияния гласных"
Vowels:0 <=> _ Vowels;
```

###### результат

```
лIы<q>:лIа
лIы<neg>:лIэп
лIы<abs>:лIы
унэ<q>:уна
унэ<neg>:унэп
унэ<abs>:унэ
шъуз<abs>:шъуз
шъуз<q>:шъуза
шъуз<neg>:шъузэп
```
:::

Обратим внимание, что `Vowels:0` в рамках нашей задачи можно было бы записать экономичнее `:0` (см. ниже раздел @sec-dif-representations). Однако, такое правило при моделировании большего фрагмента грамматики скорее всего может привести к непредвиденным эффектам. Тем более, что такая запись плохо читаема вне контекста.

Определение множеств может содержать имена множеств, определенных ранее. Все перечисленные в множествах единицы должны быть определены в разделе `Alphabet`.

Определяемые элементы в разделе Sets не могут иметь `:`. Раскрытие переменных происходит по обычным правилам: если после или до имени переменной не стоит двоеточия, значит он будет раскрываться подобными симвалами (т. е. `а` перейдет в `а:а` и т. д.). В нашем примере переменная `Vowels` в файле `.twol` раскрылась всеми возможными способами: `а` -- `а`, `а` -- `ы`, `а` -- `э`, `ы` -- `ы`, `ы` -- `э`, `э` -- `э`. Т. е. каждое употребление переменной

Раздел `Definitions` --- опциональный раздел `.twol` файла, в котором можно давать некоторым левым или правым фрагментам контекста имена, к которым потом можно обращаться в правилах. Это осмысленно, если один и тот же контекст встречается в разных правилах, пример из [@beesley2003: 29]

```{{twol}}
...
Definitions

  XContext = [ p | t | k | g:k ] ;
  YContext = [ m | n | n g ] ;
  
...
```

Кроме того, внутри правил можно создавать свои переменные. Так адыгейский трансдьюсер для устранения зияния гласных можно переписать, опеределяя переменную прямо в правиле, а не в разделе `Sets`:

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
Root Infl

LEXICON Root
шъуз
лIы
унэ

LEXICON Infl
<abs>:
<neg>:эп
<q>:а
```

###### `twol`

```{{twol}}
Alphabet
    I а з л н п у ш ъ ы э
    а:0 ы:0 э:0;

Rules

"устранение зияния гласных"
Vowels:0 <=> _ [а | ы | э];
    where Vowels in (а ы э);
```

###### результат

```
лIы<q>:лIа
лIы<neg>:лIэп
лIы<abs>:лIы
унэ<q>:уна
унэ<neg>:унэп
унэ<abs>:унэ
шъуз<abs>:шъуз
шъуз<q>:шъуза
шъуз<neg>:шъузэп
```
:::

Кажется, что правило можно было бы еще упростить и использовать переменную дважды:

```
Vowels:0 <=> _ Vowels;
    where Vowels in (а ы э);
```

К сожалению, это работает неправильно:

```
лIы<abs>:лIы
лIы<q>:лIыа
лIы<neg>:лIыэп
унэ<neg>:унэп
унэ<abs>:унэ
унэ<q>:унэа
шъуз<abs>:шъуз
шъуз<q>:шъуза
шъуз<neg>:шъузэп 
```

Дело в том, что программа расписывает такое правило следующим образом:

```
а:0 <=> _ а;
ы:0 <=> _ ы;
э:0 <=> _ э;
```

А для корректной работы, нужно следующее расписывание:

```
а:0 <=> _ [а ы э];
ы:0 <=> _ [а ы э];
э:0 <=> _ [а ы э];
```

Интересно, почему это работало в случае, если определить переменную в разделе `Sets`.

Переменных может быть несколько, и после их определения значения у созданных переменных можно соединить, используя аргумент `matched`. Рассмотрим это на примере палатализации в польском (индоевропейские, славянские):

|               | признак | нога    | рука   |
|---------------|---------|---------|--------|
| \<nom\>\<sg\> | _cecha_ | _noga_  | _ręka_ |
| \<acc\>\<sg\> | _cechę_ | _nogę_  | _rękę_ |
| \<dat\>\<sg\> | _cesze_ | _nodze_ | _ręce_ |

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
Root Infl

LEXICON Root
cecha<n>:cech
noga<n>:nog
ręka<n>:ręk

LEXICON Infl
<nom><sg>:a
<acc><sg>:ę
<dat><sg>:{dat.sg}e
```

###### `twol`

```{{twol}}
Alphabet
    a c h e n o g r ę k
    k:c g:dz h:sz c:0
    %{dat.sg%}:0;

Rules

"палатализация"
C:Cpal <=> _ %{dat.sg%}:0;
    where C in (k g h)
          Cpal in (c dz sz)
          matched ;

"починка диграфа ch -> sz"
c:0 <=> _ h:sz;

"гиперфонема для дательного"
%{dat.sg%}:0 <=> _;
```

###### результат

```
cecha<n><dat><sg>:cesze
cecha<n><nom><sg>:cecha
cecha<n><acc><sg>:cechę
noga<n><nom><sg>:noga
noga<n><acc><sg>:nogę
noga<n><dat><sg>:nodze
ręka<n><nom><sg>:ręka
ręka<n><acc><sg>:rękę
ręka<n><dat><sg>:ręce
```
:::

В файле `.twol` в правиле `палатализация` были созданы две переменные `C` и `Cpal`, которые были определены ниже. Также в этом `.twol` файле есть пример соответствия одному входному символу многосимвольный выход (`g:dz`). К сожалению, нельзя определять многосимвольные входные символы кроме как через гиперфонемы. `matched` в правиле означает, не свободное определение переменных, а определенные отношения, если определено несколько переменных: первый элемент одной переменной соотносится с первым элементом второй переменной и т. д. Если `matched` убрать, то программа будет генерировать все возможные комбинации. 

### Операторы и другое

- `.#.` --- означает границу слова (как левую так, и правую)
- Операторы квантификации
    - Оператор `?` --- ноль или один раз
    - Оператор `*` --- ноль и более раз
    - Оператор `+` --- один и более раз
    - Оператор `^n` --- n раз
    - Оператор `^n,m` --- от n до m раз

Операторы квантификации важны, так как позволяют задавать сложные контексты для моделирования дистантных отношений.

- Оператор `\` работает как логическое не, например `\Vowels` задает контекст для единц, не входящих в группу `Vowels`.

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
Root

LEXICON Root
aa 
ba 
la 
ma 
xa 
ya 
za
```

###### `twol`

```{{twol}}
Alphabet
    a b l m x y z a:b;

Sets
    X = x y z;

Rules

"change"
a:b <=> \X _;
```

###### результат

```
aa:bb
ba:bb
xa      # есть в X
ya      # есть в X
za      # есть в X
la:lb
ma:mb
```
:::

- Оператор `|` имеет семантику 'или', что в данном случае будет работать как объединение множеств

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
Root

LEXICON Root
aa 
ba 
la 
ma 
xa 
ya 
za
```

###### `twol`

```{{twol}}
Alphabet
    a b l m x y z a:b;

Sets
    X = x y z;
    Y =   y z l m;

Rules

"change"
a:b <=> X | Y _;
```

###### результат

```
aa
ba
xa:xb   # есть в X
ya:yb   # есть и в X, и Y
za:zb   # есть и в X, и Y
la:lb   # есть в Y
ma:mb   # есть в Y
```
:::

Так в одном из примеров выше для переходов после мягких основ существует одинаковый контекст, так что можно использовать объединение при помощи оператора `|` (квадратные скобки добавлены для удобочитаемости, работает и без них):

::: {.panel-tabset}

###### с оператором

```{{twol}}
Alphabet
  а и м н п я Т
  %{А%}:а %{А%}:я %{Ы%}:ы %{Ы%}:и %{j%}:0;

Rules

"удаляем маркер мягкой основы" 

%{j%}:0 <=> _ ;

"гласные после мягкой основы" 

[ %{А%}:я | %{Ы%}:и ] <=> %{j%}:0 _ ;
```

###### без оператора как выше

```{{twol}}
Alphabet
  а и м н п я Т
  %{А%}:а %{А%}:я %{Ы%}:ы %{Ы%}:и %{j%}:0;

Rules

"удаляем маркер мягкой основы" 

%{j%}:0 <=> _ ;

"гласные после мягкой основы в номинативе" 

%{А%}:я <=> %{j%}:0 _ ;

"гласные после мягкой основы в генетиве" 

%{Ы%}:и <=> %{j%}:0 _ ;
```

:::

- Оператор `&` имеет семантику 'и', что в данном случае будет вызывать пересечение множеств

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
Root

LEXICON Root
aa 
ba 
la 
ma 
xa 
ya 
za
```

###### `twol`

```{{twol}}
Alphabet
    a b l m x y z a:b;

Sets
    X = x y z;
    Y =   y z l m;

Rules

"change"
a:b <=> X & Y _;
```

###### результат

```
aa
ba
xa      # есть в X
ya:yb   # есть и в X, и Y
za:zb   # есть и в X, и Y
la      # есть в Y
ma      # есть в Y
```
:::

- Оператор `-` имеет семантику 'без', что в данном случае будет вызывать разность множеств

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
Root

LEXICON Root
aa 
ba 
la 
ma 
xa 
ya 
za
```

###### `twol`

```{{twol}}
Alphabet
    a b l m x y z a:b;

Sets
    X = x y z;
    Y =   y z l m;

Rules

"change"
a:b <=> X - Y _;
```

###### результат

```
aa
ba
xa:xb   # есть в X
ya      # есть и в X, и Y
za      # есть и в X, и Y
la      # есть в Y
ma      # есть в Y
```
:::



::: {.callout-note}

###### Задание 03_03

Заполните раздел правил в файле `.twol` ниже, чтобы получившийся трансдьюсер моделировал образование сравнительной степени в английском (германские, индоевропейские), например, `big` - `bigger`:

::: {.panel-tabset}

###### `lexd`

```{{lexd}}
PATTERNS
Root Infl

LEXICON Root
big
hot
sad
thin
wet
# group 2
bright
cheap
cold
deep
hard
high
old
rich
small
slick
soft
tall

LEXICON Infl
<comp>:{comp}er
```

###### `twol`

```{{twol}}
Alphabet
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    0:g 0:t 0:d 0:n
    %{comp%}:0;

Sets
    Vowels = a e i o u y;

Rules

"геминация"


"гиперфонема для морфологии"


```

:::

:::

### Операторы правил {#sec-rule-operators}

Существует 4 оператора правил, однако на практике вам чаще всего понадобиться только первый. В [@beesley2003] даются следующие определения этим операторам:

- `a:b <=> l _ r ;`
    - Positive Reading 1: Если появляется пара `a:b`, то она должна быть в контексте `l _ r`.
    - Negative Reading 1: Если пара `a:b` появляется вне контекста `l _ r`, программа выдает ошибку.
    - Positive Reading 2: Если глубинное `a` появляется в контексте `l _ r`, тогда оно должно быть реализовано на поверхностном уровне как `b`.
    - Negative Reading 2: Если глубинное `a` появляется в контексте `l _ r` и реализуется на поверхностном уровне чем-то кроме как `b`, программа выдает ошибку.
- `a:b => l _ r ;`
    - Positive Reading: Если появляется пара `a:b`, то она должна быть в контексте `l _ r`.
    - Negative Reading: Если пара `a:b` появляется вне контекста `l _ r`, программа выдает ошибку.
- `a:b <= l _ r ;`
    - Positive Reading: Если глубинное `a` появляется в контексте `l _ r`, тогда оно должно быть реализовано на поверхностном уровне как `b`.
    - Negative Reading: Если глубинное `a` появляется в контексте `l _ r` и реализуется на поверхностном уровне чем-то кроме как `b`, программа выдает ошибку.
- `a:b /<= l _ r ;`
    - Positive Reading: Глубинное `а` никогда не может быть реализовано на поверхностном уровне как `b` в контексте `l _ r`
    - Negative Reading: Если глубинное `а` реализовано на поверхностном уровне как `b` в контексте `l _ r`, программа выдает ошибку.

Ниже приводится таблица из [@beesley2003], которая иллюстрирует поведение операторов:

| оператор         | пример 1    | пример 2    | пример 3     | пример 4    |
|------------------|-------------|-------------|--------------|-------------|
| `a:b <=> l _ r;` | **lar:lbr** | ~~lar:lar~~ | **lbr:lbr**  | ~~xay:xby~~ |
| `a:b => l _ r;`  | **lar:lbr** | **lar:lar** | **lbr:lbr**  | ~~xay:xby~~ |
| `a:b <= l _ r;`  | **lar:lbr** | ~~lar:lar~~ | **lbr:lbr**  | **xay:xby** |
| `a:b /<= l _ r;` | ~~lar:lbr~~ | **lar:lar** | **lbr:lbr**  | **xay:xby** |

В большинстве случаев нужно использовать оператор `<=>`. Потребность в других операторах возникает только если есть конфликтующие правила.

## Морфонология {#sec-morphonology}

Морфонология может иметь разный вид в языке, в связи с чем, я предлагаю разные трюки для описания их в `twol`.

- морфонология связана с аффиксом: `root-{morphonology}aff`
- морфонология связана с определенными корнями:
    - `root{morphonology}-aff`
    - или ввести косвенные основы в `.lexd`
- морфонология вызывается взаимодействием определенных корней и аффиксов (*око* - *очи*, но *яблоко* - *яблоки*):
    - `root{morphonology}-{morphonology}aff`
    - или ввести новые единицы в `.lexd`
- уникальные лексемы/формы всегда можно словарно ввести в `.lexd`

## Глоссирование

Все это время анализ, который мы получали, содержал исключительно грамматические теги без морфемных границ. Основной разработчик парадигмы правилового морфологического анализа --- Apertium --- скорее заинтересован в создании переводчиков, поэтому морфемные границы отходят на второй план. Однако ожидание большинства лингвистов все же заключается в том, что морфемные границы в анализе должны быть, так как для них нет другой мотивации вкладываться в работу над морфологическим анализатором, кроме как если у них есть множество неотглоссированных текстов, которые они не хотят глоссировать вручную.

Получается так:

- На вход мы подаем текст на языке.
- На выходе мы получаем множество пар, где каждый элемент это
    - анализ с поморфемной разбивкой;
    - материал на языке с поморфемной разбивкой.

Отметим, что морфологическая граница традиционно в таких случаях обозначается `>`. Это не самый удобный для читаемости символ, но его ожидают разные другие полезные инструменты на основе трансдьюсеров. Если мы хотим разработать инструмент для глоссироваания, нам имеет смысл создать два похожих трансдьюсера:

- walk\>s --- walk\<v\>\>\<pres\>\<3\>\<sg\>
- walks --- walk\<v\>\>\<pres\>\<3\>\<sg\>

Один от другого отличается одним правилом в `twol`.

## Мысли в сторону

Важно отметить, что `twol` отлично помогает моделировать переходы от глубинного представления в поверхностное, что помогает моделировать (мор)фонологию. Однако не стоит считать двухуровневую фонологию фонологической теорией. Она разрабатывалась прежде всего для практических нужд, а в таком случае все средства хороши. Правила двухуровневой фонологии часто слишком языкоцентричны, и поэтому сложно перейти от них к некоторым обобщениям. Кроме того, отказ от последовательности правил приводит к тому, что получившиеся правила двухуровневой фонологии часто неестественны, так как вынуждены включать в себя работу сразу всех (мор)фонологических процессов языка.
