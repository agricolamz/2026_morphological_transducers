# Как распространять работу?

Существует достаточно много причин, по которой необходимо уметь распространять свою работу:

- **Резервное копирование**. Хранить свою работу в одном месте достаточно недальновидно: компьютеры ломаются, ноутбуки крадут, да и люди (а теперь и набирающие популярность LLM-агенты) могут сделать ошибку, которая приведет к потере данных.
- **Возможность совместной работы**. Разместив проект в некотором общедоступном месте, вы значительно облегчите совместную разработку.
- **Возможность получить обратную связь и помощь**. Разместив проект в некотором общедоступном месте, вы значительно облегчите другим процесс оценки вашей работы. Не говоря уже о том, что общедоступный проект может привлечь внимание некоторого стороннего разработчика, который захочет как-то улучшить проект.
- **История изменений**. Все современные системы для работы с кодом поддерживают в том или ином виде историю изменений. Иногда это делают даже облачные системы, которые раз в некоторое время синхронизируются с вашей файловой системой. Это очень полезно, так как позволяет вернутся на несколько шагов назад, если с вашим процессом разработки пошло что-то не так.
- **Запуск сервиса**. Если хочется сделать сервис, чтобы люди в мире могли пользоваться результатами вашего труда, имеет смысл сделать так, чтобы вашу работу можно было скачать и установить на отдельном сервере (в контейнере и т. п.).

## Cимволы подстановки (wildcards)

Как и во многих языках программирования командная строка поддерживает символы подстановки. Хоть я приведу все примеры с программой `ls`, легко представить себе и более осмысленные задачи. Для примера, представим, что у нас есть папка с большим количеством файлов:

```{{shell}}
$ ls multiple_files
```

```{r}
system("ls examples/09_multiple_files", intern = TRUE) |> 
  cat(sep = "\n")
```

Мы можем вывести все файлы содержащие двойку, добавив `*` -- любое количество символов:

```{{shell}}
$ ls multiple_files/*2*
```

```{r}
system("ls examples/09_multiple_files/*2*", intern = TRUE) |> 
  cat(sep = "\n")
```

Это же используют для поиска файлов с каким-либо определенным расширением:

```{{shell}}
$ ls multiple_files/*.csv
```

```{r}
system("ls examples/09_multiple_files/*.csv", intern = TRUE) |> 
  cat(sep = "\n")
```

Кроме того звездочку можно использовать и без каких либо окружающих символов, тогда будут перечислены все файлы. Например, следующий команда удаляет все файлы в папке `multiple_files`.

```{{shell}}
$ rm multiple_files/*
```

Если известно точное количество символов, то можно использовать символ `?`, который обозначает один символ. Выведем только файлы с четырьмя символами до расширения:

```{{shell}}
$ ls multiple_files/????.*
```

```{r}
system("ls examples/09_multiple_files/????.*", intern = TRUE) |> 
  cat(sep = "\n")
```

Искать можно и по расширению:

```{{shell}}
$ ls multiple_files/a_1.???
```

```{r}
system("ls examples/09_multiple_files/a_1.???", intern = TRUE) |> 
  cat(sep = "\n")
```

Кроме того можно задавать группы при помощи квадратных скобок:

```{{shell}}
$ ls multiple_files/[aouie]*
```

```{r}
system("ls examples/09_multiple_files/[aouie]*", intern = TRUE) |> 
  cat(sep = "\n")
```

## Введение в `git`

```{r}
#| out-width: 40%
#| fig-cap: "источник: https://xkcd.com/1597/"
#| fig-align: center

knitr::include_graphics("images/09_01_xkcd.png")
```

### `.gitignore`

Символы подстановки очень полезны при создании файла `.gitignore`. `.gitignore` --- это специальный скрытый файл[^hidden], в котором вы можете перечислить файлы, которые программа `git` должна игнорировать (см. [документацию](https://git-scm.com/docs/gitignore)). 

[^hidden]: Скрытые файлы или папки начинаются с точки и не высвечиваются по команде `ls` (но высвечиваются по команде `ls -a`). Скрытые файлы часто хранят конфигурационные файлы или какие-то данные, которые используют программы. Эта категория файлов создана, чтобы пользователь случайно не переписал или удалил какой-то из файлов. 

При создании морфологического анализатора достаточно обмениваться файлами `.lexd`, `.twol`, `.cg3` и инструкциями по компиляции анализатора, которые обычно записывают в `Makefile` (см. раздел @sec-makefile). Получающиеся файлы вроде `.hfst` или `.hfstol` хотелось бы не закоммитить случайно созданона GitHub. В связи с этим в вашем репозитории имеет смысл перечислить файлы, которые следует игнорировать версии контроля. Вот как будет выглядеть такой файл `.gitignore`:

```
*.hfst
*.hfstol
```

Позже может так случится, что вы будете хранить в той же папке литературу и/или данные, которые нельзя выкладывать, их тоже можно будет добавить в файл `.gitignore`. Кроме того у GitHub есть ограничения на размер файла (вроде 100мб?..), если он увидит большие файлы, то он не даст их добавить, так что если они есть в вашем проекте, их тоже следует добавить в `.gitignore`.

### `git hooks`

Кажется удобным, чтобы проверки, которые мы обсудили в @sec-tests, можно было проводить каждый раз перед тем как делать коммит. Для этого были придуманы `git hooks` (подробнее можно почитать [здесь](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)). Если Вы написали скрипт для проверки, то его можно записать в файл `.git/hooks/pre-commit`, тогда каждый раз он будет запускаться. Можно даже сделать так, чтобы коммит не отправлялся, если тест не проходит.

## Программа `make` {#sec-makefile}

В ходе курса мы видели, что для того, чтобы скомпилировать морфологический анализатор и генератор достаточно достаточно маленьких текстовых файлов и целая вереница команд в командной строке. Понятно, что достаточно бессмысленно пробовать держать в памяти нужный порядок команд. Для этого придумали (в 1976 году) программу, которая называется `make`, которая последовательно запускает череду инструкций, которые записаны в виде терминальных команд в файле `Makefile` (см. огромную [документацию](https://www.gnu.org/software/make/manual/make.html)). В результате, в идеальном сценарии, пользователь скачивает папку, набирает в терминале `make` и получает рабочий анализатор. 

`Makefile` представляет собой собрание рецептов следующей структуры:


```{{Makefile}}
target: dependency1 dependency2 ...
[Tab ↹]<script>
```

Обратите внимание, что перед скриптом стоит один таб (ваш текстовый редактор может заменить его на пробелы).

Рассмотрим следующий игрушечный трансдьюсер:

```{{shell}}
$ cat example.lexd
```

```{r}
readLines("examples/09_example.lexd") |> 
  cat(sep = "\n")
```

```{{shell}}
$ cat example.twol
```

```{r}
readLines("examples/09_example.twol") |> 
  cat(sep = "\n")
```

```{{shell}}
$ cat ru_en.lexd
```

```{r}
readLines("examples/09_ru_en.lexd") |> 
  cat(sep = "\n")
```

Создадим следующий файл `Makefile`:

```{{shell}}
$ cat Makefile
```

```{r}
readLines("examples/09_Makefile") |> 
  cat(sep = "\n")
```

Запустим наш `Makefile`:

```{{shell}}
$ make
```

```{r}
system("make -f 09_Makefile_modified -C examples", intern = TRUE) |> 
  stringr::str_subset("make: ", negate = TRUE) |> 
  stringr::str_remove("09_") |> 
  cat(sep = "\n")
```

Применим получившийся трансдьюсер:

```{{shell}}
$ echo "ночка" | hfst-lookup analyzer_english_stem.hfst
```

```{r}
system('echo "ночка" | hfst-lookup examples/analyzer_english_stem.hfst', intern = TRUE) |> 
  cat(sep = "\n")
```

```{r}
system("make clean -f 09_Makefile_modified -C examples")
```

Теперь мы научились хранить инструкции по компиляции в `Makefile`.

В рецептах можно использовать переменные:

- `$@` (целевой объект),
- `$^` (список зависимостей),
- `$<` (первая из зависимостей).

Тогда наш `Makefile` можно переписать следующим образом:

```{{shell}}
$ cat Makefile
```

```{r}
readLines("examples/09_Makefile_upgrade") |> 
  cat(sep = "\n")
```

Ради интереса можно посмотреть на `Makefile`, который мы использовали в начале занятий:

```{r}
readLines("examples/09_Makefile_from_begining") |> 
  cat(sep = "\n")
```

