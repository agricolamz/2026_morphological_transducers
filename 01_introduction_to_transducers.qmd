---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Автоматический морфологический анализ

Морфологический анализ, как его обычно видят лингвисты, обычно включает в себя несколько вещей:

- определение морфологической формы (например, латинское *mensam* --- [acc.sg]{.smallcaps});
- приведение к начальной форме или основе (*mensam* --- *mensa*, ж. р., первое склонение);
- перевод основы (*mensam* --- 'стол').

В зависимости от целей люди делают акцент на разные аспекты морфологического анализа. Для многих NLP задач полезным является приведение к начальной форме, лингвистический корпусной анализ практически невозможен без заранее определенных морфологических форм, и все три необходимы для представления языкового материала в научной работе. Также стоит помнить, что для разных задач могут быть важны разные категории, например, лингвисты, когда приводят примеры, редко перечисляют несловоизменительную информацию (например, род для существительных), которая может быть важна в каких-то задачах.

## Приведение к основе (stemming)

Достаточно широкое применение в ранюю эпоху NLP получили методы, которые позволяют привести словоформы к основе или квазиоснове. Эта процедура помогала уменьшить разнообразие форм в тексте, что облегчало поиск и извлечение информации. В работе [@singh17] приводится целая классификация стемеров:

```{r}
knitr::include_graphics("images/01_00_stemmers.png")
```

## Много данных

Обычно, если много данных, люди используют нейросети. Для морфологического анализа русского языка их использовали в следующих работах [@arefyev18; @sorokin18; @bolshakova19a; @bolshakova19b; @bolshakova20; @garipov23]. Используются разные архитектуры:

- cвёрточные нейронные сеть (convolutional neural network, CNN);
- деревья решения с градиентным бустингом (decision trees with gradient boosting);
- двунаправленная длинная цепь элементов краткосрочной памяти (Biderectional long short-term memory network, Bi-LSTM);
- и другие.

Другой важный проект, который можно упомянуть в этом разделе: [UDPipe](https://ufal.mff.cuni.cz/udpipe/2) --- проект, основанный на размеченных в формате [Universal Dependencies трибанках](https://universaldependencies.org/) большого количества языков  [@straka18]. Отметим, что их задача амбициознее: они строят модель, совмещающую морфологический парсер и синтаксический парсер дерева зависимостей. Внутри: длинная цепь элементов краткосрочной памяти (LSTM), которая работает на основе векторного представления слов.

Также стоит упомянуть проект [Morfessor](http://morpho.aalto.fi/projects/morpho/), в котором используют скрытые марковские цепи (HMM) [@gronroos14].

## Другие правиловые подходы

Стоит отметить, что существуют не основанные на трансдьюсерах правиловые подходы, например, 

- проект `uniparser-morph` Тимофея Архангельского [@arkhangelskiy12];
- нечто, что работает в SIL Fieldworks;
- множество узконаправленных парсеров, написанных для конкертных языков.

## От автоматов к морфологическим трансдьюсерам

### Конечные автоматы {#sec-automata}

Теория автоматов --- это дисциплина на стыке математики и компьютерных наук, которая появилась в XX веке. Первые конечных автоматов были предложены в работах [@mealy55; @moore56]. Данный раздел основан на первой главе из [@beesley03: 1--42].

Под автоматами мы понимаем абстрактные машины, которые принимают разные состояния, а изменение состояний вызывается некоторым действием:

```{r}
#| eval: false

library(DiagrammeR)
grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=18]
  0 [label="0"];
  1 [label="1"];
  0 -> 1 [label="вверх"];
  0 -> 0 [label="вниз"];
  1 -> 1 [label="вверх"];
  1 -> 0 [label="вниз"];
}')

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  0 [label="закр."];
  1 [label="откр."];
  0 -> 1 [label="пропуск"];
  0 -> 0 [label="толчок"];
  1 -> 1 [label="пропуск"];
  1 -> 0 [label="толчок"];
}') 
```

```{r}
#| layout: "[[1,4],[1,4]]"

knitr::include_graphics("images/01_01_light_switch.jpg")
knitr::include_graphics("images/01_02_light_switch_automaton.png")
knitr::include_graphics("images/01_03_turnstile.jpg")
knitr::include_graphics("images/01_04_turnstile_automaton.png")
```

Мы не будем давать формального определения конечных автоматов, а перечислим его составляющие:

- алфавит, который автомат понимает;
- конечное количество состояний;
- переходы между состояниями;
- одно начальное состояние (часто обозначют нулем);
- набор конечных состояний (часто обозначают двойным кружочком).

Конечные автоматы можно использовать для побуквенной верефикации поданных на вход слов:

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  4 [label="4: ✔️",shape=doublecircle];
  5 [label="5: ✘",shape=doublecircle];
  0 -> 1 [label="с"];
  0 -> 5 [label="не с"];
  1 -> 2 [label="л"];
  1 -> 5 [label="не л"];
  2 -> 3 [label="о"];
  2 -> 5 [label="не о"];
  3 -> 4 [label="н"];
  3 -> 5 [label="не н"];
}') 
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_05_elephant.png")
```

Если программа смогла пройти путь до конечного состояния (обозначен двойным кружочком), значит операция завершилась успехом, в остальных случаях --- неудачей. Обычно путь, ведущий к неудаче, не отображают.

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  4 [label="️4",shape=doublecircle];
  0 -> 1 [label="с"];
  1 -> 2 [label="л"];
  2 -> 3 [label="о"];
  3 -> 4 [label="н"];
}') 
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_06_elephant_short.png")
```

Можно сделать так, чтобы автомат верефицировал несколько слов:

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  4 [label="4",shape=doublecircle];
  
  0 -> 1 [label="с"];
  1 -> 2 [label="л"];
  2 -> 3 [label="о"];
  3 -> 4 [label="н"];
  
  0 -> 5 [label="у"];
  5 -> 6 [label="к"];
  6 -> 7 [label="л"];
  7 -> 8 [label="о"];
  8 -> 4 [label="н"];
  
  0 -> 9 [label="к"];
  9 -> 10 [label="у"];
  10 -> 11 [label="л"];
  11 -> 12 [label="о"];
  12 -> 4 [label="н"];
}')
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_07_multiple_words.png")
```

Полученный автомат можно оптимизировать, так, чтобы там было меньше узлов, а задачи он решал те же самые:

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  4 [label="4",shape=doublecircle];
  
  0 -> 1 [label="с"];
  1 -> 2 [label="л"];
  2 -> 3 [label="о"];
  3 -> 4 [label="н"];
  
  0 -> 5 [label="у"];
  5 -> 1 [label="к"];
  
  0 -> 6 [label="к"];
  6 -> 1 [label="у"];
}')
```

```{r}
#| out-width: 70%

knitr::include_graphics("images/01_08_multiple_words_optimized.png")
```

Различают детерминированные и недетерминированные конечные автоматы. Последние отличаются от первых тем, что не выполняют одно из следующих требований:

- любой переход единственным образом определяется по текущему состоянию и входному символу;
- чтение входного символа требуется для каждого изменения состояния.

Существуют математические работы, доказывающие, что для любого регулярного языка существует детерминированный конечный автомат **с наименьшим** возможным числом состояний. Такой автомат единственен с точностью до изоморфизма. Нам это важно как знание, что наши лингвистические автоматы можно оптимизировать.

Важно отметить, что в данном разделе наши автоматы были представлены диаграммами состояний, однако автомат можно представить и в виде таблицы переходов, в которой каждая строка соотвествует одному состоянию, а столбцу допустимый входной символ (и выходной, если речь о трансдьюсерах, см. ниже). Данный формат еще называют ATT. Дополнительный столбец может соответсвовать столбцу весов.

| исходное состояние | следующее состояние | входной символ |
|--------------------|---------------------|----------------|
| 0                  | 1                   | с              |
| 1                  | 2                   | л              |
| 2                  | 3                   | о              |
| 3                  | 4                   | н              |
| 0                  | 5                   | у              |
| 5                  | 1                   | к              |
| 0                  | 6                   | к              |
| 6                  | 1                   | у              |

То же самое, записанное в формате БНФ (Бэкусовская нормальная форма или Бэкуса-Науэра форма):

```
0::с1|у5|к6
1::л2
2::о3
3::н4  
5::к1
6::у1
```

### Трансдьюсеры {#sec-transducers}

Всё, что мы рассмотрели до этого момента, позволяло лишь принимать/отвергать слова, поданные на вход. Если мы немного усложним автомат, добавив в него еще выходной алфавит, то мы получим трансдьюсер (в [русской википедии](https://ru.wikipedia.org/wiki/Конечный_автомат_с_выходом) они названы конечными автоматами с выходом). Мы будем использовать обновленную нотацию: то, что представлено на вход, мы пишем слева от двоеточия, а то, что получается на выходе --- справа.

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  4 [label="4",shape=doublecircle];
  
  0 -> 1 [label="с:с"];
  1 -> 2 [label="л:л"];
  2 -> 3 [label="о:о"];
  3 -> 4 [label="н:н"];
  
  0 -> 5 [label="у:у"];
  5 -> 1 [label="к:к"];
  
  0 -> 6 [label="к:к"];
  6 -> 1 [label="у:у"];
}')
```

```{r}
knitr::include_graphics("images/01_09_first_transducer.png")
```

В добавку к проверке наших слов, которое обеспечивалось конечными автоматами, мы получаем нечто на выходе. Пока в нашем примере на выходе получается то же самое, что на входе. Пустую строку принято обозначать греческой буквой эпсилон: `ε`. Таким образом мы можем представить трансдьюсер, который, наконец-то, делает некоторый морфологический анализ.

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  9 [label="9",shape=doublecircle];
  
  0 -> 1 [label="с:с"];
  1 -> 2 [label="л:л"];
  2 -> 3 [label="о:о"];
  3 -> 4 [label="н:н"];
  
  0 -> 5 [label="у:у"];
  5 -> 1 [label="к:к"];
  
  0 -> 6 [label="к:к"];
  6 -> 1 [label="у:у"];
  
  4 -> 7 [label="ε:<n>"];
  7 -> 9 [label="ε:<nom><sg>"];
  7 -> 8 [label="о:<ins><sg>"];
  8 -> 9 [label="м:ε"];
}')
```


```{r}
knitr::include_graphics("images/01_10_morphology.png")
```

| вход      | выход                      |
|-----------|----------------------------|
| _слон_    | _слон_\<n\>\<nom\>\<sg\>   |
| _слоном_  | _слон_\<n\>\<ins\>\<sg\>   |
| _уклон_   | _уклон_\<n\>\<nom\>\<sg\>  |
| _уклоном_ | _уклон_\<n\>\<ins\>\<sg\>  |
| _кулон_   | _кулон_\<n\>\<nom\>\<sg\>  |
| _кулоном_ | _кулон_\<n\>\<ins\>\<sg\>  |

Важно также отметить, что вообще-то не обязательно что-то делать на каждом этапе. Можно сделать трансдьюсер, который по духу будет автоматом, но дойдя до некоторого состояния, будет выдавать лэйбл.

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  3 [label="3",shape=doublecircle];
  
  0 -> 1 [label="[ð]:ε"];
  1 -> 2 [label="[ɪ]:ε"];
  2 -> 3 [label="[s]:this"];
  1 -> 3 [label="[ə]:the"];
  
  0 -> 4 [label="[k]:ε"];
  4 -> 5 [label="[æ]:ε"];
  5 -> 3 [label="[t]:cat"];
  5 -> 3 [label="[n]:can"];
}')
```

```{r}
knitr::include_graphics("images/01_12_morphology2.png")
```

Лингвистические трансдьюсеры можно использовать для

- морфологического анализа
- транслитерации/транскрипции
- предиктивного ввода
- в системах проверки правописания
- в системах автоматического перевода близкородственных языков
- в системах распознавания речи
- и др.

С трансдьюсерами можно делать много разных операций:

- объединение (конечные и начальные состояния совпадают, все промежуточные сохраняются);
- конкатенация (конечное состояние одного трансдьюсера становится начальным состоянием другого);
- пересечение (в особых случаях;
- вычитание (в особых случаях);
- композиция (обсудим ниже).

Композиция трансдьюсеров аналогична функциям `join` для таблиц. После композиции трансдьюсера <x, y>  и <y, z>  получается новый трансдьюсер <x, z>.

```{r}
#| eval: false

grViz('
  digraph G { rankdir="LR"
  node [fontname="Brill",shape=circle,fontsize=14,fixedsize=true]
  edge [fontname="Brill",fontsize=16]
  6 [label="6",shape=doublecircle];
  12 [label="12",shape=doublecircle];
  19 [label="19",shape=doublecircle];
  
  0 -> 1 [label="в:c"];
  1 -> 2 [label="о:r"];
  2 -> 3 [label="р:o"];
  3 -> 4 [label="о:w"];
  4 -> 5 [label="н:ε"];
  5 -> 6 [label="а:ε"];
  7 -> 8 [label="w:с"];
  8 -> 9 [label="r:r"];
  9 -> 10 [label="o:o"];
  10 -> 11 [label="n:w"];
  11 -> 12 [label="a:ε"];
  13 -> 14 [label="в:w"];
  14 -> 15 [label="о:r"];
  15 -> 16 [label="р:o"];
  16 -> 17 [label="о:n"];
  17 -> 18 [label="н:a"];
  18 -> 19 [label="а:ε"];
}')
```

```{r}
knitr::include_graphics("images/01_11_transducer_composition.png")
```

Именно при помощи композиции трансдьюсеров можно объединять трансдьюсеры с разными "целями": например, трансдьюсер, который приводит к начальной форме и пишет морфологические теги, с трансдьюсером, который переводит основы. Кроме того, бывают взвешенные трансдьюсеры, в которых каждому переходу в новое состояние приписывается некоторый вес. Такой трансдьюсер позволяет не просто получать возможные варианты, но и ранжировать их, что важно при создании спеллчекеров.

Закончим перечислением преимуществ трансдьюсеров. Оптимизированный трансдьюсер оптимален с точки зрения объема требуемой памяти для хранения и скорости поиска. Композиция трансдьюсеров открывает большой и богатый мир, позволяет создавать и комбинировать между собой очень разные инструменты.

## Проблемы моделирования морфологии языка

- Проблема описаний:
    - неполнота: то, что исследователи посчитали достаточным для грамматического описания, может быть недостаточно для моделирования; для некоторого языка может быть доступно грамматическое описание, но отсутствовать словарь и наоборот; словарь может не содержать информации про словоизменительный класс каких-то единиц, которые различаются в грамматическом описании.
    - противоречивые источники: грамматические описания могут противоречить друг другу; грамматические описания могут противоречить словарям
- Проблема вариативности:
    - идиолектная
    - диалектная
    - связанная с какими-нибудь социолингвистическими параметрами (в первую очередь такие как пол и возраст, но можно придумать и другие)
- Проблема неоднозначности (особенно перекошенной частотно):
    - лексической
    - морфологическая
    - синтаксическая
    - ...
- Проблема идиом и суплетивизма: в какой форме стоит глагол в ругательстве *\*\* твою мать*?
- Проблема циклов, возникающих при словообразовании:
    - слуга (N) > служить (V) > услужить (V) > услужение (N), услуга (N)[^etymology]
- Проблема морфологической сложности: для языков с бедной морфологией проще строить прсотой правиловый морфологический парсер, а не трансдьюсер
- Технические сложности: весь софт для создания морфологических трансдьюсеров пишут под Linux, за исключением может быть пакета [`hfst-dev`](https://pypi.org/project/hfst-dev/) для Python
- Не так просто работать совместно над одним проектом, чаще всего лучше иметь двух людей --- специалиста по языку, и специалиста по трансдьюсерам. 

Смотрите еще обсуждения на FST в работе [@wintner2008].
    
[^etymology]: Я лишь предполагаю такую историческую деревацию, возможно, этимологии этих слов таят в себе значительно более сложную историю.
